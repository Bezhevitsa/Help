#include <iostream>
#include <stack>
#include <string>
#include <list>
#include "ConsoleApplication1.h"
#include <map>


/*

6.1

Решение задач на применение stack.
Проверить правильность скобочного выражения

Написать функцию для проверки правильности расстановки скобок (,),[,],{,}
в введенном пользователем выражении (наборе различных символов)
за линейное время (один просмотр выражения).

2+4-5(87192479_7348){72648]76823[] -> no

({}) -> yes

({)} -> no



Алгоритм решения

Считываем элемент.
Если это (,[ или {, то помещаем ее в стек.
Если это ),] или }, то сравниваем с верхним элементом стека.
Если образовалась пара, то верхний элемент стека удаляем.
Иначе - выражение неправильное.

Когда все элементы считали, то проверяем стек на пустоту.
Если стек пуст, то выражение правильное.
Иначе - выражение неправильное.

6.2

Решение задач на применение deque.
Деком (англ. deque – аббревиатура от double-ended queue, двухсторонняя очередь)
называется структура данных, в которую можно удалять и добавлять элементы как в начало,
так и в конец.

Дек хранится в памяти так же, как и очередь.

ЗАДАЧА 1

Проверить, является ли введенная строка палиндромом
(читается одинаково слева направо и справа налево). Использовать дек.

Алгоритм решения:
Считываем строку посимвольно. каждый символ добавляем в хвост дека.
Далее сравниваем первый и последний символ дека.



ЗАДАЧА 2

Реализовать поиск выпуклой оболочки точек.

Алгоритм Грэхема.

Этот алгоритм является трехшаговым. На первом шаге ищется любая точка в A,
гарантированно входящая в выпуклую оболочку. В качестве точки можно взять точку
с наименьшей x-координатой (самая левая точка). Эту точку (будем называть ее стартовой)
перемещаем в начало дека, вся дальнейшая работа будет производиться с оставшимися точками.
Заведем дек P, в котором будут хранится номера точек (их позиции в массиве A).
Итак, первый шаг алгоритма заключается в том, чтобы первой точкой в P оказалась точка
с наименьшей x-координатой.

Второй шаг в алгоритме Грэхема — сортировка всех точек (кроме P[0]-ой),
по степени их левизны относительно стартовой точки R. Будем говорить, что B<C,
если точка С находится по левую сторону от вектора RB.
Если теперь соединить точки в полученном порядке, то получится многоугольник,
который, однако, не является выпуклым.

Третье действие. Нужно пройтись по всем вершинам и удалить те из них,
в которых выполняется правый поворот (угол в такой вершине оказывается больше развернутого).
Заводится дек S (реально список) и помещаем в него первые две вершины (они, опять же, гарантированно входят в ВО).
Затем просматриваем все остальные вершины,
и отслеживаем направление поворота в них с точки зрения последних двух вершин в стеке S:
если это направление отрицательно, то можно срезать угол удалением из стека последней вершины.
Как только поворот оказывается положительным, срезание углов завершается, текущая вершина заносится в стек.

В итоге в деке S (который теперь можно рассматривать, как список)
оказывается искомая последовательность вершин, причем в нужной нам ориентации,
определяющая МВО заданного множества точек A.



Для определения с какой стороны от вектора AB находится точка C
(положительное возвращаемое значение соответствует левой стороне, отрицательное — правой).
использовать формулу (B_x-A_x)*(C_y-B_y)-(B_y-A_y)*(C_x-B_x) - значение координаты z векторного произведения.

6.3
Решение задач на применение quelle
Напечатать в порядке возрастания первые n натуральных чисел,
в разложение которых на простые множители входят только 2, 3 и 5.

6.4

Решение задач на применение set и unordered set.
Преподаватель на экзамене дал студентам тест.
Один из студентов решил узнать правильные ответы.
Для этого он отправлял тест много раз с нескольких аккаунтов.
Преподаватель решил это пресечь. Для этого преподаватель не стал засчитывать результаты теста,
отправленного повторно с одного и того же аккаунта. Нужно автоматизировать этот процесс.

6.5
Решение задач на применение list
На вход подается список студентов в формате <номер группы> <пробел> <Фамилия>.
Нужно вывести список студентов по группам, причем в том порядке, как они были записаны
в исходном списке.

6.6
Решение задач на применение map
Подсчет количества слов в тексте и вывод частоты их встречи
в процентном соотношении (подсчет частоты встречи слов в тексте в процентах)

*/


/*
6.1

Решение задач на применение stack.
Проверить правильность скобочного выражения

Написать функцию для проверки правильности расстановки скобок (,),[,],{,}
в введенном пользователем выражении (наборе различных символов)
за линейное время (один просмотр выражения).

2+4-5(87192479_7348){72648]76823[] -> no

({}) -> yes

({)} -> no



Алгоритм решения

Считываем элемент.
Если это (,[ или {, то помещаем ее в стек.
Если это ),] или }, то сравниваем с верхним элементом стека.
Если образовалась пара, то верхний элемент стека удаляем.
Иначе - выражение неправильное.

Когда все элементы считали, то проверяем стек на пустоту.
Если стек пуст, то выражение правильное.
Иначе - выражение неправильное.

*/
void _61() {
	std::cout << std::endl << std::endl << "6.1" << std::endl;

	std::stack<char> f;
	char input[255]{ 0 };
	std::cin >> input;
	bool is_ok = true;
	for (int i = 0; i < strlen(input); i++)
	{
		char n = input[i];
		if (n == '(' || n == '[' || n == '{') {
			f.push(n);
			continue;
		}

		if (n == ')' || n == ']' || n == '}') {
			char m = f.top();
			f.pop();
			is_ok = is_ok && n == ')' && m == '(' || n == ']' && m == '[' || n == '}' && m == '{';
		}
	}

	is_ok = is_ok && f.size() == 0;

	std::cout << (is_ok ? "YES" : "NO");
}


/*6.2

Решение задач на применение deque.
Деком (англ. deque – аббревиатура от double-ended queue, двухсторонняя очередь)
называется структура данных, в которую можно удалять и добавлять элементы как в начало,
так и в конец.

Дек хранится в памяти так же, как и очередь.

ЗАДАЧА 1

Проверить, является ли введенная строка палиндромом
(читается одинаково слева направо и справа налево). Использовать дек.

Алгоритм решения:
Считываем строку посимвольно. каждый символ добавляем в хвост дека.
Далее сравниваем первый и последний символ дека.



ЗАДАЧА 2

Реализовать поиск выпуклой оболочки точек.

Алгоритм Грэхема.

Этот алгоритм является трехшаговым. На первом шаге ищется любая точка в A,
гарантированно входящая в выпуклую оболочку. В качестве точки можно взять точку
с наименьшей x-координатой (самая левая точка). Эту точку (будем называть ее стартовой)
перемещаем в начало дека, вся дальнейшая работа будет производиться с оставшимися точками.
Заведем дек P, в котором будут хранится номера точек (их позиции в массиве A).
Итак, первый шаг алгоритма заключается в том, чтобы первой точкой в P оказалась точка
с наименьшей x-координатой.

Второй шаг в алгоритме Грэхема — сортировка всех точек (кроме P[0]-ой),
по степени их левизны относительно стартовой точки R. Будем говорить, что B<C,
если точка С находится по левую сторону от вектора RB.
Если теперь соединить точки в полученном порядке, то получится многоугольник,
который, однако, не является выпуклым.

Третье действие. Нужно пройтись по всем вершинам и удалить те из них,
в которых выполняется правый поворот (угол в такой вершине оказывается больше развернутого).
Заводится дек S (реально список) и помещаем в него первые две вершины (они, опять же, гарантированно входят в ВО).
Затем просматриваем все остальные вершины,
и отслеживаем направление поворота в них с точки зрения последних двух вершин в стеке S:
если это направление отрицательно, то можно срезать угол удалением из стека последней вершины.
Как только поворот оказывается положительным, срезание углов завершается, текущая вершина заносится в стек.

В итоге в деке S (который теперь можно рассматривать, как список)
оказывается искомая последовательность вершин, причем в нужной нам ориентации,
определяющая МВО заданного множества точек A.



Для определения с какой стороны от вектора AB находится точка C
(положительное возвращаемое значение соответствует левой стороне, отрицательное — правой).
использовать формулу (B_x-A_x)*(C_y-B_y)-(B_y-A_y)*(C_x-B_x) - значение координаты z векторного произведения.*/

void _62() {
	std::cout << std::endl << std::endl << "6.2" << std::endl;

	char input[255]{ 0 };
	std::cin >> input;

	std::deque<char> q;

	for (int i = 0; i < strlen(input); i++) {
		q.push_back(input[i]);
	}

	bool is_pal = true;
	while (is_pal && q.size() > 0) {
		is_pal = q.front() == q.back();
		q.pop_back();
		q.pop_front();
	}

	std::cout << (is_pal ? "YES" : "NO");
}

bool sort_by_group(const std::string& first, const std::string& second)
{
	unsigned int i = 0;
	while ((i < first.length()) && (i < second.length()) && first[i] != ' ' && second[i] != ' ')
	{
		if (first[i] < second[i]) return true;
		if (first[i] > second[i]) return false;
		++i;
	}
	return first[i] < second[i];

}

/*6.5
Решение задач на применение list
На вход подается список студентов в формате <номер группы> <пробел> <Фамилия>.
Нужно вывести список студентов по группам, причем в том порядке, как они были записаны
в исходном списке.*/
void _65() {

	std::cout << std::endl << std::endl << "6.5" << std::endl;

	std::list<std::string> list;
	std::string input;
	std::cin.ignore();
	do {
		std::getline(std::cin, input);
		if (input.empty()) {
			break;
		}
		else {
			list.push_back(input);
		}
	} while (true);

	list.sort(sort_by_group);

	while (!list.empty()) {
		std::cout << list.front() << std::endl;
		list.pop_front();
	}
}


/*6.6
Решение задач на применение map
Подсчет количества слов в тексте и вывод частоты их встречи
в процентном соотношении (подсчет частоты встречи слов в тексте в процентах)*/
void _66() {

	std::cout << std::endl << std::endl << "6.6" << std::endl;

	std::map<std::string, int> map;

	char c;
	std::string current_word = "";
	while (true) {
		c = (char)std::cin.get();
		if (std::isalpha(c)) {
			current_word += c;
		}
		else {
			if (map.count(current_word) == 1) {
				map[current_word]++;
			}
			else if (current_word != "") {
				map.insert(make_pair(current_word, 1));
			}
			current_word = "";
		}

		if (c == '\n') {
			break;
		}
	}

	int total = 0;
	for (const std::pair<std::string, int>& pair : map) {
		total += pair.second;
	}
	std::cout << "Total: " << total << std::endl;

	for (const std::pair<std::string, int>& pair : map) {
		std::cout << pair.first << "\t=> " << 1.0 * pair.second / total << " (" << pair.second << ")" << std::endl;
	}
}

int main()
{
	_61();
	_62();
	_63();
	_65();
	_66();
}